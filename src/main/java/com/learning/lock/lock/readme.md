### Lock

---
##### I. boolean Lock.[tryLock](TryLockDeadLock.java)
1. 如果参数中有等待的时间，那么在获取锁的阻塞（**Timed_Waiting**）期间可以被中断（interrupt）。
2. 最佳实践：获取锁后，应该在**if**块内使用**try-finally**中 **_Lock.unlock_** 释放锁。
3. 与synchronize的关系和不同点：Lock不是用来替代synchronize的;Lock尝试获取锁时可以被中断以及未能在指定时间内获取锁可以执行其它逻辑(有返回值)

---
##### II. void Lock.[lockInterruptibly](LockInterruptibly.java)
没有返回值，相当于tryLock(无限期)

---
##### III. happens-before
加锁前可以看到前一个解锁后发生的所有语句

---
##### IV. 乐观锁（非互斥同步锁）、悲观锁（互斥同步锁）
乐观锁：初始开销比悲观锁小，但竞争较为激烈的情况下长时间的自旋会致使**开销越来越大** 。
实例：Atomic*, 版本管理器Git

悲观锁：初始开销较大，但开销固定。
实例：synchronize,Lock

悲观锁适用场景：临界区竞争激烈，长时间阻塞如：临界区有IO操作，临界区代码复杂或者循环量大。

乐观锁适用场景：并发写入少，大部分是读取场景，不加锁能让读取性能大幅度提高。

---
##### V. [可重入锁](ReentrantLockDemo.java)、非可重入锁
可重入锁避免了死锁的发生（调用链中的两个方法被同一个锁限制时）
方法：ReentrantLock.getHoldCount/getQueueLength

---
##### VI. [公平锁](FairLock.java)、非公平锁
非公平锁：填补了线程被唤醒期间的空白时间，当线程需要锁时会尝试插队获取锁(刚释放锁的线程大概率能再次拿到锁)，如果获取不到则进入等待获取锁的队列中。

优点：提高吞吐量 缺点：会造成起饥饿线程的产生。

公平锁：按照请求锁的顺序排队获取锁。

---
##### VII. [共享锁（读锁）、独享锁（排它锁）](ReentrantReadWriteLockDemo.java)
1. 只有读锁和读锁之间可以共享临界区

2. _ReentrantReadWriteLock_ **非公平锁** 的情况下：

    a. 插队：指的是*插队获取锁*，不是指在等待获取锁的队列中插队；
    
    b. 插队时机：（大概是代码运行到需要获取锁的那一刻）如果已经进入等待获取锁的队列，那么就不会再有插队的机会，阻塞的线程就只能按顺序获取锁了；
    
    c. 获取*读锁*时的**插队条件**（读锁太容易插队会导致获取写锁的线程饥饿）：**占有临界资源的线程持有的是读锁**（不然插个毛的队！），**等待锁的队列中第一个线程需要的是读锁**（一般情况都应该是写锁，所以这种情况很少或时间段很小）。
    
    d. 获取*写锁*的插队条件：无，因为本来能获取锁的概率就低，只有在临界区的读写锁都没有被其它线程占有的情况下才有机会获得写锁。
    




